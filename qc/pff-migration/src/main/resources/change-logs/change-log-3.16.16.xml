<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd
        http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">
	<property name="add.schema" value="dbo." dbms="mssql" />
	<property name="add.schema" value=" " dbms="oracle" />
	<property name="call.substr" value="substring" dbms="mssql" />
	<property name="call.substr" value="substr" dbms="oracle" />
	<property name="call.substr" value="substring" dbms="postgresql" />
	<property name="call.auditdb" value="PFFBFSQCAudit.." dbms="mssql" />
	<property name="call.auditdb" value=" " dbms="oracle" />
	<property name="call.concatenate" value="+" dbms="mssql" />
	<property name="call.concatenate" value="||" dbms="oracle" />
	<property name="call.concatenate" value="||" dbms="postgresql" />
	<property name="call.collength" value="LEN" dbms="mssql" />
	<property name="call.collength" value="LENGTH" dbms="oracle" />
	<property name="call.collength" value="LENGTH" dbms="postgresql" />
	<property name="call.date" value="getdate()" dbms="mssql" />
	<property name="call.date" value="sysdate" dbms="oracle" />
	<property name="call.date" value="now()::timestamp" dbms="postgresql" />
	
	<changeSet id="1" author="Manoj" dbms="oracle">
	<createView viewName="INT_MANDATE_REQUEST_VIEW" replaceIfExists="true">
		SELECT M.MANDATEID, 
			BD.BANKSHORTCODE BANKCODE,
			BD.BANKNAME,
			case when LB.BRANCHCODE IS NULL THEN CB.BRANCHCODE ELSE LB.BRANCHCODE END BRANCHCODE,
      		case when LB.BRANCHDESC IS NULL THEN CB.BRANCHDESC ELSE LB.BRANCHDESC END BRANCHDESC,
			CUST.CUSTCIF,
			CUST.CUSTSHRTNAME,
			FT.FINTYPEDESC FINTYPE ,
			FIN.FINREFERENCE ,
			COALESCE((SELECT SUM(MAX(FSD.REPAYAMOUNT+FSD.FEESCHD)) FROM FINSCHEDULEDETAILS FSD INNER JOIN FINANCEMAIN FM ON FM.FINREFERENCE =FSD.FINREFERENCE AND FM.CUSTID = M.CUSTID GROUP BY FM.FINREFERENCE)/CCYMINORCCYUNITS, 0) CUST_EMI,
			COALESCE((SELECT SUM(MAX(FSD.REPAYAMOUNT+FSD.FEESCHD)) FROM FINSCHEDULEDETAILS FSD WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID = M.MANDATEID) GROUP BY FINREFERENCE)/CCYMINORCCYUNITS, 0) EMI,
			  CASE M.OPENMANDATE
			    WHEN 1
			    THEN 'New Open ECS'
			    ELSE 'No Open ECS'
			  END OPENMANDATE,
			M.ACCNUMBER,
			M.ACCTYPE,
			M.ACCHOLDERNAME,
			BB.MICR,
			(select MIN(FIRSTREPAYDATE) from FINPFTDETAILS where FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) FIRSTDUEDATE,
			(select MAX(SCHDATE) from FINSCHEDULEDETAILS where (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) and FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) EMIENDDATE,
			 COALESCE (M.MAXLIMIT/CCYMINORCCYUNITS, 0) MAXLIMIT, 
      COALESCE((SELECT SUM(MAX(REPAYAMOUNT+FEESCHD)) MANDATEDEBITAMOUNT FROM FINSCHEDULEDETAILS WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)
      GROUP BY FINREFERENCE), 0)/CCYMINORCCYUNITS DEBITAMOUNT,
			  M.STARTDATE,
			  M.EXPIRYDATE,
			  FIN.APPLICATIONNO,
			  M.MANDATETYPE,
			  M.STATUS,
			  M.INPUTDATE,
			  M.RECORDSTATUS,
			  M.RECORDTYPE,
        	M.MANDATECCY,
			  COALESCE (CCY.CCYMINORCCYUNITS, 100) CCYMINORCCYUNITS
			FROM MANDATES M
			INNER JOIN BANKBRANCHES BB ON BB.BANKBRANCHID = M.BANKBRANCHID
			INNER JOIN BMTBANKDETAIL BD ON BD.BANKCODE=BB.BANKCODE 
			INNER JOIN CUSTOMERS CUST   ON CUST.CUSTID = M.CUSTID
			INNER JOIN RMTBRANCHES CB ON CB.BRANCHCODE = CUST.CUSTDFTBRANCH 
			LEFT OUTER JOIN RMTCURRENCIES CCY ON CCY.CCYCODE = M.MANDATECCY
			LEFT OUTER JOIN FINANCEMAIN FIN ON M.ORGREFERENCE=FIN.FINREFERENCE
			LEFT JOIN RMTBRANCHES LB ON LB.BRANCHCODE = FIN.FINBRANCH 
			LEFT OUTER JOIN RMTFINANCETYPES FT ON FIN.FINTYPE =FT.FINTYPE 
			WHERE M.STATUS = 'NEW' AND M.MANDATEID NOT IN  (select MANDATEID FROM MANDATE_REQUESTS where (status = 'AC' OR status = 'NEW'))
	</createView>
</changeSet>
<changeSet id="1" author="Manoj" dbms="mssql">
	<createView viewName="INT_MANDATE_REQUEST_VIEW" replaceIfExists="true">
		SELECT M.MANDATEID, 
			BD.BANKSHORTCODE BANKCODE,
			BD.BANKNAME,
			case when LB.BRANCHCODE IS NULL THEN CB.BRANCHCODE ELSE LB.BRANCHCODE END BRANCHCODE,
      		case when LB.BRANCHDESC IS NULL THEN CB.BRANCHDESC ELSE LB.BRANCHDESC END BRANCHDESC,
			CUST.CUSTCIF,
			CUST.CUSTSHRTNAME,
			FT.FINTYPEDESC FINTYPE ,
			FIN.FINREFERENCE ,
			COALESCE((SELECT SUM(Max_Amt) from(SELECT MAX(FSD.REPAYAMOUNT+FSD.FEESCHD) Max_Amt,FM.FINREFERENCE FinRef FROM FINSCHEDULEDETAILS FSD INNER JOIN FINANCEMAIN FM ON FM.FINREFERENCE =FSD.FINREFERENCE AND FM.CUSTID = M.CUSTID GROUP BY FM.FINREFERENCE)T )/CCYMINORCCYUNITS, 0) CUST_EMI,
			COALESCE((SELECT SUM(Max_Amt) from (Select MAX(FSD.REPAYAMOUNT+FSD.FEESCHD) Max_Amt ,Fsd.FINREFERENCE Finref  FROM FINSCHEDULEDETAILS FSD WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID = M.MANDATEID) GROUP BY FINREFERENCE)T )/CCYMINORCCYUNITS, 0) EMI,
			  CASE M.OPENMANDATE
			    WHEN 1
			    THEN 'New Open ECS'
			    ELSE 'No Open ECS'
			  END OPENMANDATE,
			M.ACCNUMBER,
			M.ACCTYPE,
			M.ACCHOLDERNAME,
			BB.MICR,
			(select MIN(FIRSTREPAYDATE) from FINPFTDETAILS where FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) FIRSTDUEDATE,
			(select MAX(SCHDATE) from FINSCHEDULEDETAILS where (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) and FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) EMIENDDATE,
			 COALESCE (M.MAXLIMIT/CCYMINORCCYUNITS, 0) MAXLIMIT, 
      COALESCE((SELECT SUM(MANDATEDEBITAMOUNT) from (Select (MAX(REPAYAMOUNT+FEESCHD)) MANDATEDEBITAMOUNT, FINREFERENCE FINREF FROM FINSCHEDULEDETAILS WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID = M.MANDATEID) GROUP BY FINREFERENCE)T 
      ), 0)/CCYMINORCCYUNITS DEBITAMOUNT,
			  M.STARTDATE,
			  M.EXPIRYDATE,
			  FIN.APPLICATIONNO,
			  M.MANDATETYPE,
			  M.STATUS,
			  M.INPUTDATE,
			  M.RECORDSTATUS,
			  M.RECORDTYPE,
        	M.MANDATECCY,
			  COALESCE (CCY.CCYMINORCCYUNITS, 100) CCYMINORCCYUNITS
			FROM MANDATES M
			INNER JOIN BANKBRANCHES BB ON BB.BANKBRANCHID = M.BANKBRANCHID
			INNER JOIN BMTBANKDETAIL BD ON BD.BANKCODE=BB.BANKCODE 
			INNER JOIN CUSTOMERS CUST   ON CUST.CUSTID = M.CUSTID
			INNER JOIN RMTBRANCHES CB ON CB.BRANCHCODE = CUST.CUSTDFTBRANCH 
			LEFT OUTER JOIN RMTCURRENCIES CCY ON CCY.CCYCODE = M.MANDATECCY
			LEFT OUTER JOIN FINANCEMAIN FIN ON M.ORGREFERENCE=FIN.FINREFERENCE
			LEFT JOIN RMTBRANCHES LB ON LB.BRANCHCODE = FIN.FINBRANCH 
			LEFT OUTER JOIN RMTFINANCETYPES FT ON FIN.FINTYPE =FT.FINTYPE 
			WHERE M.STATUS = 'NEW' AND M.MANDATEID NOT IN  (select MANDATEID FROM MANDATE_REQUESTS where (status = 'AC' OR status = 'NEW'))
	</createView>
</changeSet>
<changeSet id="1" author="Manoj" dbms="postgresql">
	<createView viewName="INT_MANDATE_REQUEST_VIEW" replaceIfExists="true">
		SELECT M.MANDATEID, 
			BD.BANKSHORTCODE BANKCODE,
			BD.BANKNAME,
			case when LB.BRANCHCODE IS NULL THEN CB.BRANCHCODE ELSE LB.BRANCHCODE END BRANCHCODE,
      		case when LB.BRANCHDESC IS NULL THEN CB.BRANCHDESC ELSE LB.BRANCHDESC END BRANCHDESC,
			CUST.CUSTCIF,
			CUST.CUSTSHRTNAME,
			FT.FINTYPEDESC FINTYPE ,
			FIN.FINREFERENCE ,
			COALESCE((SELECT SUM(Max_Amt) from(SELECT MAX(FSD.REPAYAMOUNT+FSD.FEESCHD) Max_Amt,FM.FINREFERENCE FinRef FROM FINSCHEDULEDETAILS FSD INNER JOIN FINANCEMAIN FM ON FM.FINREFERENCE =FSD.FINREFERENCE AND FM.CUSTID = M.CUSTID GROUP BY FM.FINREFERENCE)T )/CCYMINORCCYUNITS, 0) CUST_EMI,
			COALESCE((SELECT SUM(Max_Amt) from (Select MAX(FSD.REPAYAMOUNT+FSD.FEESCHD) Max_Amt ,Fsd.FINREFERENCE Finref  FROM FINSCHEDULEDETAILS FSD WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID = M.MANDATEID) GROUP BY FINREFERENCE)T )/CCYMINORCCYUNITS, 0) EMI,
			  CASE M.OPENMANDATE
			    WHEN 1
			    THEN 'New Open ECS'
			    ELSE 'No Open ECS'
			  END OPENMANDATE,
			M.ACCNUMBER,
			M.ACCTYPE,
			M.ACCHOLDERNAME,
			BB.MICR,
			(select MIN(FIRSTREPAYDATE) from FINPFTDETAILS where FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) FIRSTDUEDATE,
			(select MAX(SCHDATE) from FINSCHEDULEDETAILS where (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) and FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID=M.MANDATEID)) EMIENDDATE,
			 COALESCE (M.MAXLIMIT/CCYMINORCCYUNITS, 0) MAXLIMIT, 
      COALESCE((SELECT SUM(MANDATEDEBITAMOUNT) from (Select (MAX(REPAYAMOUNT+FEESCHD)) MANDATEDEBITAMOUNT, FINREFERENCE FINREF FROM FINSCHEDULEDETAILS WHERE (REPAYONSCHDATE = 1 OR PFTONSCHDATE = 1) AND FINREFERENCE IN (SELECT FINREFERENCE FROM FINANCEMAIN WHERE MANDATEID = M.MANDATEID) GROUP BY FINREFERENCE)T 
      ), 0)/CCYMINORCCYUNITS DEBITAMOUNT,
			  M.STARTDATE,
			  M.EXPIRYDATE,
			  FIN.APPLICATIONNO,
			  M.MANDATETYPE,
			  M.STATUS,
			  M.INPUTDATE,
			  M.RECORDSTATUS,
			  M.RECORDTYPE,
        	M.MANDATECCY,
			  COALESCE (CCY.CCYMINORCCYUNITS, 100) CCYMINORCCYUNITS
			FROM MANDATES M
			INNER JOIN BANKBRANCHES BB ON BB.BANKBRANCHID = M.BANKBRANCHID
			INNER JOIN BMTBANKDETAIL BD ON BD.BANKCODE=BB.BANKCODE 
			INNER JOIN CUSTOMERS CUST   ON CUST.CUSTID = M.CUSTID
			INNER JOIN RMTBRANCHES CB ON CB.BRANCHCODE = CUST.CUSTDFTBRANCH 
			LEFT OUTER JOIN RMTCURRENCIES CCY ON CCY.CCYCODE = M.MANDATECCY
			LEFT OUTER JOIN FINANCEMAIN FIN ON M.ORGREFERENCE=FIN.FINREFERENCE
			LEFT JOIN RMTBRANCHES LB ON LB.BRANCHCODE = FIN.FINBRANCH 
			LEFT OUTER JOIN RMTFINANCETYPES FT ON FIN.FINTYPE =FT.FINTYPE 
			WHERE M.STATUS = 'NEW' AND M.MANDATEID NOT IN  (select MANDATEID FROM MANDATE_REQUESTS where (status = 'AC' OR status = 'NEW'))
	</createView>
</changeSet>

<changeSet id="2" author="Manojkumar">
	<sql>
		delete from errordetails where errorcode = 'LDAP64';
		INSERT INTO ErrorDetails VALUES('LDAP64','EN','E','{0} does not exists in Active Directory.','','Approved','','','','','',0,sysdate,1000,0);
	</sql>
</changeSet>

<changeSet id="3" author="Somasekhar">
		<insert tableName="ErrorDetails">
			<column name="ErrorCode">90403</column>
			<column name="ErrorLanguage">EN</column>
			<column name="ErrorSeverity">E</column>
			<column name="ErrorMessage">No Objection Certificate is only applicable for Matured and closed(Fully Paid) loans.</column>
			<column name="ErrorExtendedMessage"></column>
			<column name="RecordStatus">Approved</column>
			<column name="RoleCode"></column>
			<column name="NextRoleCode"></column>
			<column name="TaskId"></column>
			<column name="NextTaskId"></column>
			<column name="RecordType"></column>
			<column name="WorkflowId">0</column>
			<column name="LastMntOn"></column>
			<column name="LastMntBy">1000</column>
			<column name="Version">1</column>
		</insert>
	</changeSet>
		<changeSet id="4" author="Jayant" dbms="oracle">
	    <sql splitStatements="false">
	        begin
	        	SP_INVALIDVIEWS;
	        	RESEED_SEQUENCE_TABLES;
	        end;
	    </sql>
	</changeSet>
		<changeSet id="5" author="Siva">
	    <sql>
	       DELETE from bmtamountcodes where amountcode  IN ('ae_rpExcessTds', 'ae_rpEmiAdvTds', 'ae_rpPayableTds');
	    </sql>
	</changeSet>
	<changeSet id="6" author="Sriram" >
	<createView viewName="PAYMENTDETAILS_VIEW" replaceIfExists="true">
	  SELECT	 T1.PaymentDetailId, T1.PaymentId, T1.AmountType, T1.Amount, T1.ReferenceId,
				 T1.Version, T1.LastMntBy, T1.LastMntOn, T1.RecordStatus, T1.RoleCode, T1.NextRoleCode,
				 T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId,FT.FEETYPEDESC,FT.FEETYPECODE
		FROM     PaymentDetails_Temp  T1 LEFT OUTER JOIN MANUALADVISE_TEMP MA ON T1.REFERENCEID=MA.ADVISEID LEFT OUTER JOIN FEETYPES_TEMP FT  on MA.FEETYPEID=FT.FEETYPEID
		UNION ALL
		SELECT	 T1.PaymentDetailId, T1.PaymentId, T1.AmountType, T1.Amount, T1.ReferenceId,
				 T1.Version, T1.LastMntBy, T1.LastMntOn, T1.RecordStatus, T1.RoleCode, T1.NextRoleCode,
				 T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId,FT.FEETYPEDESC,FT.FEETYPECODE
		FROM     PaymentDetails  T1  LEFT OUTER JOIN MANUALADVISE MA ON T1.REFERENCEID=MA.ADVISEID LEFT OUTER JOIN FEETYPES FT  on MA.FEETYPEID=FT.FEETYPEID
		WHERE NOT EXISTS ( SELECT 1  FROM PaymentDetails_Temp WHERE PaymentDetailId = T1.PaymentDetailId)
	</createView>
	</changeSet>
	
	<changeSet author="Kesav" id="7">
		<addColumn tableName="LimitStructure">
			<column name="ReBuild" type="boolean"/>
		</addColumn>
	</changeSet>
	<changeSet author="Kesav" id="8">
		<addColumn tableName="LimitStructure_Temp">
			<column name="ReBuild" type="boolean"/>
		</addColumn>
	</changeSet>
	<changeSet author="Kesav" id="9">
		<addColumn tableName="CustomerQueuing">
			<column name="LoanExist" type="boolean"/>
		</addColumn>
	</changeSet>
	<changeSet author="Kesav" id="10">
		<addColumn tableName="CustomerQueuing_Log">
			<column name="LoanExist" type="boolean"/>
		</addColumn>
	</changeSet>
	
	<changeSet author="Kesav" id="11">
		<createView viewName="LIMITSTRUCTURE_AVIEW" replaceIfExists="true">
			SELECT		T1.LimitCategory,T1.StructureCode, T1.StructureName, T1.Active,T1.LimitCheckFilter,T1.ShowLimitsIn, T1.ReBuild, 
						T1.Version ,T1.CreatedBy,T1.CreatedOn, T1.LastMntBy, T1.LastMntOn,T2.UsrLogin,T2.UsrFName, T2.UsrMName, T2.UsrLName, T1.RecordStatus, 
						T1.RoleCode, T1.NextRoleCode, T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId
			FROM    	LimitStructure T1 INNER JOIN
						SecUsers T2 ON T1.LastMntBy = T2.UsrID		
		</createView>
	</changeSet>
	
	<changeSet author="Kesav" id="12">
		<createView viewName="LIMITSTRUCTURE_TVIEW" replaceIfExists="true">
			  SELECT		T1.LimitCategory,T1.StructureCode, T1.StructureName, T1.Active	,T1.LimitCheckFilter,T1.ShowLimitsIn, T1.ReBuild,
							T1.Version ,T1.CreatedBy,T1.CreatedOn, T1.LastMntBy, T1.LastMntOn,T2.UsrLogin,T2.UsrFName, T2.UsrMName, T2.UsrLName, T1.RecordStatus, 
							T1.RoleCode, T1.NextRoleCode, T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId
			  FROM    		LimitStructure_Temp T1 INNER JOIN
							SecUsers T2 ON T1.LastMntBy = T2.UsrID		
		</createView>
	</changeSet>
	
	<changeSet author="Kesav" id="13">
		<createView viewName="LIMITSTRUCTURE_VIEW" replaceIfExists="true">
			  SELECT		T1.LimitCategory,T1.StructureCode, T1.StructureName, T1.Active	,T1.LimitCheckFilter,T1.ShowLimitsIn, T1.ReBuild,
							T1.Version ,T1.CreatedBy,T1.CreatedOn, T1.LastMntBy, T1.LastMntOn,T2.UsrLogin,T2.UsrFName, T2.UsrMName, T2.UsrLName, T1.RecordStatus, 
							T1.RoleCode, T1.NextRoleCode, T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId
			  FROM    		LimitStructure_Temp T1 INNER JOIN
							SecUsers T2 ON T1.LastMntBy = T2.UsrID 
			
			  UNION ALL
			
			  SELECT		T1.LimitCategory,T1.StructureCode, T1.StructureName, T1.Active	,T1.LimitCheckFilter,T1.ShowLimitsIn, T1.ReBuild,
							T1.Version ,T1.CreatedBy,T1.CreatedOn, T1.LastMntBy, T1.LastMntOn,T2.UsrLogin,T2.UsrFName, T2.UsrMName, T2.UsrLName, T1.RecordStatus, 
							T1.RoleCode, T1.NextRoleCode, T1.TaskId, T1.NextTaskId, T1.RecordType, T1.WorkflowId
			  FROM    		LimitStructure T1 INNER JOIN
							SecUsers T2 ON T1.LastMntBy = T2.UsrID
			  WHERE     NOT EXISTS (SELECT 1 FROM LimitStructure_Temp WHERE StructureCode = T1.StructureCode)		
		</createView>
	</changeSet>
	
	<changeSet author="Kesav" id="14">
		<createTable tableName="CUSTOMERGROUPQUEUING">
			<column name="GROUPID" type="bigint">
				<constraints nullable="false" primaryKey="true"/>
			</column>
			<column name="EODDATE" type="datetime">
				<constraints nullable="false"/>
			</column>
			<column name="STARTTIME" type="datetime"/>
			<column name="ENDTIME" type="datetime"/>
			<column name="PROGRESS" type="int"/>
			<column name="ERRORLOG" type="varchar(2000)"/>
			<column name="STATUS" type="varchar(15)"/>	
		</createTable>
	</changeSet>
	
	<changeSet author="Kesav" id="15">
		<createTable tableName="CUSTOMERGROUPQUEUING_LOG">
			<column name="GROUPID" type="bigint">
				<constraints nullable="false"/>
			</column>
			<column name="EODDATE" type="datetime">
				<constraints nullable="false"/>
			</column>
			<column name="STARTTIME" type="datetime"/>
			<column name="ENDTIME" type="datetime"/>
			<column name="PROGRESS" type="int"/>
			<column name="ERRORLOG" type="varchar(2000)"/>
			<column name="STATUS" type="varchar(15)"/>	
		</createTable>
	</changeSet>	
	
	<changeSet id="16" author="Kesav">
	<sql>
		Update LimitStructure set Rebuild = '0' where Rebuild is null;
		Update LimitStructure_Temp set Rebuild = '0' where Rebuild is null;
	</sql>
</changeSet>
<changeSet id="17" author="Prasad">
	<createView viewName="RPT_VOUCHER_VIEW" replaceIfExists="true">
		Select P.finEvent STAGEID,LinkedTranId LEA_VOUCHERID,PostDate VOUCHERDATE,
       B.BRANCHSWIFTBRNCDE BRANCHID,P.FInType PRODUCTFLAG,P.FINREFERENCE,
       P.FINSTARTDATE AGREEMENTDATE,
       CASE WHEN P.FINCURRASSETVALUE=P.FINASSETVALUE then 'Fully Disbursed' WHEN P.FINCURRASSETVALUE!=P.FINASSETVALUE then 'Partially Disbursed' else null end DISB_STATUS,
       CASE WHEN P.FinIsActive is null then null WHEN P.FinIsActive=1 then 'Active' WHEN P.closingstatus='C' then 'Cancelled' else 'Closed' end CURRENT_STATUS,
       CASE WHEN P.closingstatus is null then null WHEN P.closingstatus='W' then 'WRITEOFF' else 'REGULAR ' end NPA_STAGEID,
       P.Account FINNONE_GLID,AT.ActypeDesc GROUPGLDESC,to_char(Coalesce(DRAMT/ccyMinorCcyUnits,0),'99999999999999D00') DRAMT,
       to_char(Coalesce(CRAMT/ccyMinorCcyUnits,0) ,'99999999999999D00') CRAMT, 
       AT.TAXAPPLICABLE GST_APPLICABLE,B.BRANCHPROVINCE FROM_STATEID,Case when FT.PROVINCE is not null then FT.PROVINCE else custAddrPRovince end TO_STATEID,
       P.PostRef PostReference
		from (Select LinkedTranId,PostDate,finEvent,transorder,Account,PostBranch,ACCcy,FINREFERENCE,custid,FInType,FINSTARTDATE,FINCURRASSETVALUE,FINASSETVALUE,FinIsActive,closingstatus,PostRef,DRAMT,CRAMT from (
      Select P.LinkedTranId,P.PostDate,P.finEvent,P.transorder,P.Account,P.PostBranch,P.ACCcy,P.FINREFERENCE,FM.custid,FM.FInType,FM.FINSTARTDATE,FM.FINCURRASSETVALUE,FM.FINASSETVALUE,FM.FinIsActive,FM.closingstatus,P.FINREFERENCE PostRef,
             P.DRORCR,P.PostAmount
      from PLF.postings P 
	  LEFT join PLF.Financemain FM on FM.finreference = P.finreference where (P.PostAmount != 0) and FinEvent != 'VASFEE'
      union all
      Select P.LinkedTranId,P.PostDate,P.finEvent,P.transorder,P.Account,P.PostBranch,P.ACCcy,V.Primarylinkref,FM.custid,FM.FInType,FM.FINSTARTDATE,FM.FINCURRASSETVALUE,FM.FINASSETVALUE,FM.FinIsActive,FM.closingstatus,P.FINREFERENCE PostRef,
	  P.DRORCR,P.PostAmount
      from PLF.postings P 
	  inner join PLF.vasrecording V on V.vasreference = P.finreference
	  Left join PLF.FinanceMain FM on FM.Finreference = V.PRIMARYLINKREF where (P.PostAmount != 0)
	  )PIVOT (sum(PostAmount) for DRORCR in('D' as DRAMT ,'C' as CRAMT))) P 	  
	  inner join PLF.RMTBranches B on B.BranchCOde = P.PostBranch INNER JOIN 
     PLF.AccountMapping AM  ON AM.ACCOUNT = P.ACCOUNT INNER JOIN 
     PLF.RMTACCOUNTTYPES AT   ON AT.ACTYPE = AM.ACCOUNTTYPE INNER JOIN 
     PLF.RMTCURRENCIES RC on RC.ccyCode = P.ACCcy LEFT JOIN
     PLF.FinTaxDetail FT on FT.FINREFERENCE = P.FINREFERENCE LEFT JOIN
     PLF.CUSTOMERADDRESSES CA on CA.Custid =P.custid and CustAddrPriority=5
	</createView>
</changeSet>

	<changeSet author="Kesav" id="18">
		<addColumn tableName="CustomerQueuing">
			<column name="LimitRebuild" type="boolean"/>
		</addColumn>
	</changeSet>
	
	<changeSet author="Kesav" id="19">
		<addColumn tableName="CustomerQueuing_Log">
			<column name="LimitRebuild" type="boolean"/>
		</addColumn>
	</changeSet>
	
	<changeSet id="20" author="Kesav">
		<sql>
			Update CustomerQueuing set LimitRebuild = 0 where LimitRebuild is null;
			Update CustomerQueuing_Log set LimitRebuild = 0 where LimitRebuild is null;
		</sql>
	</changeSet>
	<changeSet id="21" author="Jayant" dbms="oracle">
	   <sql splitStatements="false">
	       begin
	        SP_INVALIDVIEWS;
	        RESEED_SEQUENCE_TABLES;
	       end;
	   </sql>
</changeSet>
</databaseChangeLog>