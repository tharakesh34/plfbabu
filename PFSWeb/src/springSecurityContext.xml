<?xml version="1.0" encoding="UTF-8"?>

<!-- Spring namespace-based configuration -->

<beans:beans xmlns="http://www.springframework.org/schema/security"
	xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
	       http://www.springframework.org/schema/aop   
		   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd                        
           http://www.springframework.org/schema/security
           http://www.springframework.org/schema/security/spring-security-3.1.xsd">

	<!-- ====================================================== -->
	<!-- For catching the @Secured annotation methods -->
	<!-- we use our own mechanism. -->
	<!-- Look in GFCBaseCtrl.java onEvent() method. -->
	<!-- ====================================================== -->

	<!-- Enable the @Secured annotation to secure service layer methods -->
	<global-method-security secured-annotations="enabled" />

	<http auto-config="false" use-expressions="false" entry-point-ref="authenticationEntryPoint">
	
		<!-- 
			Querying the SessionRegistry for currently authenticated users and their sessions
			http://static.springsource.org/spring-security/site/docs/3.1.x/reference/session-mgmt.html#list-authenticated-principals 
		-->
		<custom-filter ref="authenticationFilter" position="FORM_LOGIN_FILTER"/>
		<custom-filter ref="concurrencyFilter" position="CONCURRENT_SESSION_FILTER"/>
		<session-management session-authentication-strategy-ref="sas"/>

		<!-- ====================================================== -->
		<!-- If we have our own LoginPage. So we must -->
		<!-- tell Spring the name and the place. -->
		<!-- In our case we take the same page -->
		<!-- for a error message by a failure. -->
		<!-- Further the page after a successfully login. -->
		<!-- ====================================================== -->

		<!-- <form-login login-page="/loginDialog.zul"
			authentication-failure-url="/loginDialog.zul?login_error=1"
			default-target-url="/pages/index.zul" /> -->

		<!-- ====================================================== -->
		<!-- Tell Spring where it goes after logout. -->
		<!-- logout-url is a action url. -->
		<!-- ====================================================== -->

		<logout logout-url="/j_spring_logout" logout-success-url="/loginDialog.zul" />

		<!-- ====================================================== -->
		<!-- Define the pages that are to be intercepted -->
		<!-- It is parsed from top to bottom. Means that -->
		<!-- the most specific pattern is standing on TOP -->
		<!-- and the CATCH ALL is on BOTTOM! -->
		<!-- ====================================================== -->

		<intercept-url pattern="/pages/**" access="IS_AUTHENTICATED_REMEMBERED" />
		<intercept-url pattern="/WEB-INF/pages/**" access="IS_AUTHENTICATED_REMEMBERED" />

		<!-- ====================================================== -->
		<!-- The root page is accessible by everyone but -->
		<!-- internally spring makes a login and -->
		<!-- this user becames a UserDetails -->
		<!-- (in there are the ip-address and others) -->
		<!-- ====================================================== -->

		<intercept-url pattern="/**" access="IS_AUTHENTICATED_ANONYMOUSLY" />

		<!-- ====================================================== -->
		<!-- Per user one session !! -->
		<!-- In DEMO mode we set it to 5 -->
		<!-- ====================================================== -->
		<!-- v2.x <concurrent-session-control max-sessions="5" /> -->

		<session-management>
			<concurrency-control max-sessions="5" />
		</session-management>

	</http>

	<beans:bean id="authenticationFilter"
		class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"
		p:sessionAuthenticationStrategy-ref="sas" p:authenticationManager-ref="authenticationManager"
		p:authenticationFailureHandler-ref="customAuthenticationFailureHandler"
		p:authenticationSuccessHandler-ref="customAuthenticationSuccessHandler" />

	<!-- We just actually need to set the default failure URL here -->
	<beans:bean id="customAuthenticationFailureHandler"
		class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler"
		p:defaultFailureUrl="/loginDialog.zul?login_error=1" />

	<!-- We just actually need to set the default target url here -->
	<beans:bean id="customAuthenticationSuccessHandler"
		class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler"
		p:defaultTargetUrl="/pages/index.zul" />

	<!-- The AuthenticationEntryPoint is responsible for redirecting the user 
		to a particular page, like a login page, whenever the server sends back a 
		response requiring authentication -->
	<!-- See Spring-Security Reference 5.4.1 for more info -->
	<beans:bean id="authenticationEntryPoint"
		class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"
		p:loginFormUrl="/loginDialog.zul" />

	<!-- Filter required by concurrent session handling package The ConcurrentSessionFilter 
		requires two properties, sessionRegistry, which generally points to an instance 
		of SessionRegistryImpl, and expiredUrl, which points to the page to display 
		when a session has expired. See: http://static.springsource.org/spring-security/site/docs/3.1.x/reference/session-mgmt.html#list-authenticated-principals -->
	<beans:bean id="concurrencyFilter"
		class="org.springframework.security.web.session.ConcurrentSessionFilter"
		p:sessionRegistry-ref="sessionRegistry" p:expiredUrl="/loginDialog.zul" />
		
	<!-- Defines a concrete concurrent control strategy Checks whether the user 
		in question should be allowed to proceed, by comparing the number of sessions 
		they already have active with the configured maximumSessions value. The SessionRegistry 
		is used as the source of data on authenticated users and session data. See: 
		http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/session/ConcurrentSessionControlStrategy.html -->
	<beans:bean id="sas"
		class="org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy"
		p:maximumSessions="2">
		<beans:constructor-arg name="sessionRegistry"
			ref="sessionRegistry" />
	</beans:bean>

	<!-- Maintains a registry of SessionInformation instances See: http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/session/SessionRegistry.html -->
	<beans:bean id="sessionRegistry"
		class="org.springframework.security.core.session.SessionRegistryImpl" />

	<!-- ====================================================== -->
	<!-- We define the kind of authentification with a -->
	<!-- so called authentication-provider -->
	<!-- We use the DAO authenticationProvider. -->
	<!-- We coded out a custom UserDetailServiceImpl. -->
	<!-- So we have our users stored in a DB we use -->
	<!-- our own user-service class and point to her. -->
	<!-- ====================================================== -->
<authentication-manager alias="authenticationManager" erase-credentials="true">
	<authentication-provider ref="ldapActiveDirectoryAuthProvider" />
	<authentication-provider user-service-ref="myUserDetailsService">
		<!-- The password encoder is additonally for -->
		<!-- simulating a one-time-password mechanism -->
		<password-encoder ref="passwordEncoder">
			<salt-source user-property="token" />
		</password-encoder>
	</authentication-provider>
</authentication-manager>
	<!-- ====================================================== -->
	<!--           LDAP Authentication provider implementation    -->
	<!--               Class                                      -->
	<!-- ======================================================   -->
	<beans:bean id="ldapActiveDirectoryAuthProvider" class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider">
	<beans:constructor-arg value="${ldap.dominname}"  /> 	       <!--  your domain name -->
	<beans:constructor-arg value="${ladap.dominURL}"  />           <!--  your LDAP  URL   -->	
	</beans:bean>

	<!-- ====================================================== -->
	<!-- The Implementation of the Interface -->
	<!-- UserDetailService for the logged in -->
	<!-- user and his rights -->
	<!-- ====================================================== -->
	<beans:bean id="myUserDetailsService" class="com.pennant.policy.model.PolicyManager">
		<beans:property name="userService" ref="userService" />
	</beans:bean>

	<!-- ====================================================== -->
	<!-- The Password Encoder who works in the -->
	<!-- one-time-password mechanism. -->
	<!-- ====================================================== -->
	<beans:bean id="passwordEncoder" class="com.pennant.policy.PasswordEncoderImpl">
	</beans:bean>

	<!-- ====================================================== -->
	<!-- Here, only for showing in the console -->
	<!-- that we can catches the events. -->
	<!-- ====================================================== -->
	<!-- <zksp:zk-event login-template-close-delay="5"> -->
	<!-- <zksp:intercept-event path="//**/btn_*" event="onClick" -->
	<!-- access="IS_AUTHENTICATED_REMEMBERED" /> -->
	<!-- <zksp:intercept-event path="/**" event="onClick" -->
	<!-- access="IS_AUTHENTICATED_ANONYMOUSLY" /> -->

	<!-- <zksp:intercept-event path="//**/window_BranchesList/listBoxBranch" -->
	<!-- event="onClick" access="IS_AUTHENTICATED_ANONYMOUSLY" /> -->
	<!-- <zksp:intercept-event path="//**/window_BranchesList/listBoxBranch" -->
	<!-- event="onDoubleClick" access="IS_AUTHENTICATED_REMEMBERED" /> -->
	<!-- </zksp:zk-event> -->


	<!-- ====================================================== -->
	<!-- This ASPECT calls automatically the method -->
	<!-- 'loginLogging' which is for writing a log for -->
	<!-- all successfully and failed logins, if a -->
	<!-- method is called that handles the -->
	<!-- Authentication. -->
	<!-- ====================================================== -->

	<beans:bean id="LoginLoggingPolicyService"
		class="com.pennant.policy.LoginLoggingPolicyService">
		<beans:property name="guiLoginLoggingPolicService" ref="guiLoginLoggingPolicService" />
			<beans:property name="policyManager" ref="myUserDetailsService" />
	</beans:bean>

	<aop:config>
		<aop:aspect id="LoginLoggingAspect" ref="LoginLoggingPolicyService">
			<aop:pointcut id="authPointcut"
				expression="execution(public org.springframework.security.core.Authentication org.springframework.security.authentication.AuthenticationProvider.authenticate(org.springframework.security.core.Authentication))" />
			<aop:around pointcut-ref="authPointcut" method="loginLogging" />
		</aop:aspect>
	</aop:config>
	
</beans:beans>